Teacher:宋国杰
# 0.评分
![4f3c5262f018d74dbc538c7ea0b6590.jpg](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309131054925.jpg)
![42c78c08525e60fb288238701beea85.jpg](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309150918484.jpg)


# 1.概览
## 1.1解决问题的过程
<mark>*问题->数据结构->**算法**->程序*<mark>
先用自然语言描述出**算法**的思路。
## 1.2考核
### 书面提交作业要求
- 写学号、名字
- 在纯文本或PDF中写上“我保证没有抄袭其他同学的作业”。
### 上机考试
期中笔试后周三3-4节随堂考试，2.5h。5道题，所有书面作业叫到课程网。
## 1.3数据结构
### 逻辑结构
图> 树 >线性
举例：家族成员数据结构。
#### \*节点的类型
- 基本数据类型
- 复合数据类型
#### \*线性结构
亦称前驱关系。
#### \*树形结构
#### \*图形结构
### 存储结构
- 顺序方法、链接方法
- 索引方法、散列方法
存储结构建议一种逻辑结构到物理结构的映射。
#### 顺序方法
such as数组
#### 链接方法
利用指针指向
- 优点：增删容易
- 缺点：定位困难，访问结点必须知道该结点的指针。
#### 索引方法
是顺序存储法的一种推广。
构造一个映射函数。
#### 散列方法
是索引方法的拓展。
<mark>散列函数<mark>：将关键码S**映射**到非负整数Z。
### 运算
## 1.4抽象数据类型（ADT）
用数学方法定义对象集合和运算集合。
## 1.5算法
### 性质
- 通用性
- 有效性
- 确定性
- 有穷性：**算法中不能含有死循环**。
### 分类
- 穷举法
- 回溯（迷宫、八皇后）、搜索（DFS,BFS）
- 贪心法
- 递归分治（二分检索、快速排序、分治排序）
- 动态规划（Floyd算法）
### 算法分析
**时间和空间复杂性**分析。
1. 不能用绝对时间单位度量算法复杂性。（**尽管也是需要的**）环境、语言、可扩展性不同。
2. 重要的不是具体的时间，而是算法复杂性与输入数据规模（N）的关系。用N和B（基本操作）量级的函数关系来描述时间复杂性。
#### 1.大O表示法
1. 如果存在正数c和n0，使得对于任意的n>=n0，都有f(n)<=cg(n)，则称f(n)在集合O（g(n)）中，或简称f(n)是O（g(n)）的。
2. ![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309150828884.png)
3. 加法规则：f1(n)+f2(n)=O(max(f1(n),f2(n))).
4. 乘法规则：f1(n).f2(n)=O(f1(n).f2(n))
#### 2.Ω表示法
如果存在整数c和N，使得对于所有的n>=N，都有f(n)>=cg(n)，则称f(n)在集合Ω(g(n))中，或简称f(n)是Ω(g(n))的。
定义f(n)取值的<mark>下限<mark>。
#### 3.θ表示法
当上下界相同时可用此方法。
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309150832639.png)
#### 最好、最坏和平均情况
计算平均情况的复杂度应该考虑算法的所有输入情况，所以计算时应该把每种输入出现的**概率**作为权值加以考虑。
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309171621179.png)
### 时间和空间的折衷
对于同一个问题求解，一般会存在多种算法。而这些算法在时间和空间开销上的优劣往往表现出“时空折衷”的性质。
#### 空间换时间
#### 时间换空间
## 第一章课后思考
1. 数据的存储方法有哪些？简要介绍每一种存储方法的特点。
2. 给出一个求两个整数的最大公因数的算法，并分析其时间和空间复杂度。
3. ![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310031705354.png)
<mark>卡特兰数<mark>方法
4. 快慢指针问题
# 2.线性表
## 2.1 概念
### 2.1.1 抽象数据类型
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309171633220.png)
### 2.1.2线性表存储结构
#### 定长、静态的存储结构（顺序表）
#### 变长、动态的存储结构（链表）
## 2.2顺序表-向量
### 2.2.1 顺序表的类定义
### 2.2.2 顺序表的运算实现
#### 1.顺序表的检索
时间复杂度：O(1)
- 按位置查找
- 按内容查找
#### 2.顺序表的插入
##### 空间复杂性
##### 时间复杂性
#### 3.顺序表的删除
时间复杂度：O（n）
## 2.3 链表
### 2.3.1 单链表
#### 原理
Header Node(或称“哨兵”)
#### 运算
##### 1. 链表的检索
`setPos(int x);`
##### 2.链表的插入
```c++
bool insert(int ,T value);
p=setPos(i-1);
q=new ListNode;
q->next=p->next;
p->next=q;
```
##### 3.链表的删除
```c++
bool delete(int i);
p=setPos(i-1);
d=p->next;
p->next=d->next;
delete d;
```
- 设置头结点的好处： 方便处理（写代码）。
- 单链表的不足之处：link字段仅指向后继结点，不便寻找前驱。
### 2.3.2 双链表
### 2.3.3 循环链表
单链表或双链表的头尾结点链接起来，形成循环链表。不增加额外开销，但是更加方便。
## 2.4 线性表实现方法比较
### 顺序表
- 无指针域，存储密度高
- 随机访问，简便高效
- 适合存储**静态数据**
- <mark>插入删除运算时间O(n),查找为常数时间<mark>
- 预先申请固定长度的数组
### 链表
- 长度动态变化
- 表内元素动态插入和删除
- 适合存储动态数据
- <mark>插入删除时间代价O(1),但找第i个元素时间代价为O(n)。<mark>
## 2.5 课后思考
1. 设计算法将x插入到某递增有序的顺序表中。
2. ![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310031708176.png)
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310031709767.png)
# 3.栈和队列
## 3.1 栈（stack）
**限制在一端访问**的线性表。
<mark>后进先出<mark>
压栈与出栈，栈顶与栈底
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201119923.png)

### 3.1.1 栈的抽象数据类型
- push 入栈
- pop 出栈
- top 
- isEmpty
- isFull
- clear
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201116457.png)
若有n个元素依次进栈，可能的出栈序列
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201118569.png)
### 3.1.2 顺序栈
采用顺序存储结构的栈。
溢出：上溢（无空间可用）/下溢（无元素可删）
#### 入栈push
考虑栈已满的情况
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201122807.png)
#### 出栈pop
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201123913.png)
#### top
从栈顶读取，但不弹出。
#### 清空栈
#### 双栈共享一个栈空间
### 3.1.3 链式栈
**以链式储存栈**
- <mark>栈顶指针就是链表的*头指针*<mark>。
- 指针方向：从栈顶指向栈底。
- 只在链表头部操作，不需附加头结点。
- 无栈满问题，但存在栈空约束。
#### 顺序栈和链式栈的比较
##### 时间效率
- 都只需常数时间。
- 顺序栈和链式栈在时间效率上难分伯仲。
##### 空间效率
- 顺序栈必须说明一个固定的长度
- 链式栈的长度可变，但增加结构性开销。
### 3.1.4 栈的应用
<mark>后进先出特性的均可使用栈。<mark>
#### 1.栈与递归
##### 存储分配
###### 静态分配
非递归情况下，数据区的分配可以在程序运行前进行，一直到整个程序运行结束才释放。
###### 动态分配
在递归函数调用情况下，必须每调用一次分配一次，不能静态分配某些固定单元。
于是，在内存中开辟一个成为运行栈的足够大的动态区。
用作动态数据分配的存储区，分为堆（heap）和栈（stack）：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309201149594.png)
#### 2.表达式的求值
一个表达式由<mark>操作数、操作符、分界符<mark>组成。
- 表达式的组成
	- 基本符号集
	- 语法成分集：由{<表达式>,<项>,<因子>,<常数>,<数字>}5个语法成分组成
	- 语法公式集
##### 中缀表达式
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231355794.png)

##### 前缀表达式
##### 后缀表达式
- 不含括号。
- 所有求值皆按照运算符出现的顺序，严格<mark>从左向右<mark>进行。
- 求值：
	- 当遇到的是操作数，就压入栈顶。
	- 当遇到的是运算符，就从栈中两次取出栈顶，按照运算符对这两个操作数进行计算。然后将计算结构压入栈顶。
	- 如此继续，直到遇到符号=，这时栈顶的值就是输入表达式的值。
##### 中缀到后缀表达式的转换（重）
- 当输入是**操作数**，直接输出到后缀表达式序列。
- 当输入是<mark>左括号<mark>，也把它**压栈**。
- 当输入是<mark>运算符<mark>时
	- 如果
		1. 栈非空
		2. 栈顶不是左括号
		3. 输入运算符的优先级<=栈顶运算符的优先级
	 三项同时满足：**弹栈，并放回后缀表达式中**。
	 - 否则：把输入的运算符压栈（关键：当优先级大于当前栈顶运算符时才压栈）
- 当输入是<mark>右括号<mark>，先判断栈是否为空。
	- 若为空，说明异常，清栈退出。
	- 若非空，把栈中的元素依次弹出。
		- 遇到第一个左括号为止，将弹出的元素输出到后缀表达式的序列中。
		- 若没有遇到开括号，说明括号不匹配，异常处理，清栈退出。
- 最后，当中缀表达式的符号序列全部读入时，若栈内仍有元素，把它们全部依次弹出，都放到后缀表达式序列尾部。
	- 若弹出的元素遇到括号，说明括号不匹配，异常处理，清栈退出。
## 3.2 队列
只允许在一端（队头）删除，另一端（队尾）插入。
特性：<mark>先进先出<mark>。
### 主要操作
#### 入队列（enQueue）
- 顺序
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231424955.png)
- 链式
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231428147.png)

#### 出队列（deQueue）
- 顺序
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231425259.png)
- 链式
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231428446.png)

#### 取队首元素（getFront）
#### 判断队列是否为空（isEmpty）
### 抽象数据类型
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231418323.png)
### 3.2.1 顺序队列
用<mark>向量<mark>存储队列，两个变量分别指向首（front，<mark>虚的<mark>）尾（rear，<mark>实的<mark>）两端。
#### 队列的溢出
- 上溢：队列满时再做进队操作
- 下溢：队列空是再做删除操作
- 假溢出：当rear=mSize-1时，再做插入运算就会产生溢出。如果这是队列的前段还有许多空位置，这种现象称为假溢出。
### 3.2.2 链式队列
- 单链表队列：链接指针的方向是从队头指向队尾。
- 队头在链头，队尾在链尾。
- 链式队列在进队时无队满问题，但是有队空问题。
- 队空条件：front\=\=rear\=\=NULL.
### 3.2.3 队列的应用
只要满足<mark>先来先服务<mark>性质的应用均可以采用队列作为其数据组。
### 3.2.4 变种的栈或队列结构
- 双端队列：在队首和队尾都可以插入、删除的队列。
- 双栈：两个底部相连的栈，共享一块数据空间。
- 超队列：删除操作只允许在一端进行，但是插入操作可以在两端同时进行。
- 超栈：插入限制在一端而删除却运行在两端进行。
#### 思考：栈和队列的互模拟
## 3.3 课后思考
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310031711123.png)

# 4.字符串
## 4.1 字符串的基本概念
### 子串
- 空串是任意串的子串。
- 任意串S都是S本身的子串。
- 真子串：非空且不为自身的子串。
### 4.1.1 字符编码
### 4.1.2 字符的编码顺序
### 4.1.3 字符串的抽象数据类型
## 4.2 字符串的存储结构和实现
### 4.2.1 静态存储：C++标准字符串
- 采用字符数组存储。
- 长度固定。
- 不是面向对象数据类型，存在局限性。
#### 标准字符串函数
```c++
int stelrn(char *s);//返回长度
char *strcpt(char *s1,char *s2);
//s2复制给s1，返回指针指向s1
char *strcat(char *s1,char *s1);//s2拼接到s1尾部
int strcmp(char *s1,char *s2);//串比较
char *strchr(char*s,char *c);//c在s中第一次出现的位置
char *strrchr(char*s,char c);//逆向寻找c在s中第一次出现的位置
```
### 4.2.2 动态存储
- string型。
- 一种动态变长的存储结构。
#### 构造与赋值算子
#### 抽取子串函数
#### 部分算子列表
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231443784.png)

## 4.3 字符串的模式匹配
### 分类
#### 精确匹配
#### 近似匹配
#### 模式匹配
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231447300.png)
### 算法
#### 朴素算法
##### 算法内容
- 从主串T和模式串P的第一个字符开始比较。
- 相等则比较后续字符。
- 否则从新从T的第2个字符其再次与P的第1 个字符开始比较。
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231449169.png)
##### 性能分析
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202309231450091.png)
#### KMP算法
**P中每个字符对应一个移位值K，该值仅依赖于模式P本身，与目标T无关**。
##### 无回溯匹配
关键：一旦Pi与Tj比较不等时，即
P.substr(0,i)=T.substr(j-i+1i)，且Pi不等于Tj
希望立即确定右移的位数。
##### 循环串问题
[KMP算法中的循环节问题_精简](https://blog.csdn.net/destiny1507/article/details/81588116)注意借鉴其中的KMP算法
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312182044395.png)

## 4.4 课后思考
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310031717503.png)
# 5.二叉树
## 5.1 基本概念
### 5.1.1满二叉树
结点或为树叶，或有两棵非空子树。
### 5.1.2完全二叉树
#### 定义
- 最多只有最下面两层结点度数可以小于2
- 最下面一层的结点都集中在该层最左边、连续的位置上。
#### 特点
- 叶节点只可能在最下面两层出现。
- <mark>路径长度和最短。<mark>
### 5.1.3 扩充二叉树
- 出现空指针时，增加一个特殊结点——空树叶。
- 扩充二叉树是**满二叉树**。
	- N0=N2+1 新增空树叶的个数等于原来二叉树结点个数加1.
#### 性质
##### 外部路径长度E
##### 内部路径长度I
满足**E=I+2n**（n是内部结点的个数）
### 5.1.4 二叉树的主要性质
1. （**满二叉树定理**） 非空满二叉树树叶数等于其分支结点数加1. n0=n2+1
	- <mark>推理<mark>：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310111037323.png)
应用：**证明在具有n个结点的k叉树中，有n(k-1)+1个指针是空的。**
2. （**满二叉树定理推论**）一个非空二叉树的空子树（指针）数目等于其结点数+1.
3. 任何一棵二叉树，度为0的结点n0比度为2的结点n2多1个。 n0=n2+1
4. 二叉树的第i层（根为第0层）最多有2^i个结点。
5. 高度为k的二叉树至多有**2^k-1**（2^0+2^1+...+2^(k-1))个结点。
	1. 二叉树的**高度**定义为树的层数。即树中层数最大的叶节点的层数加1。
	2. 二叉树的**深度**定义为树中最长路径的长度。即书中层数最大的叶节点的层数。
6. **有n个结点的完全二叉树的高度为[log2(n+1)]+1，深度为[log2(n+1)].**
	- 证明：
	![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310111046883.png)
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310111046084.png)
7. 对于具有n个结点的完全二叉树，结点按层次由左到右编号，对任一结点i（0<=i<=n-1）有：
	1. 如果i=0，则结点i是二叉树的根节点；若i>0，则其父节点编号是[(i-1)/2]。
	2. 对于n-1
		1. 当2i+1<=n-1时，结点i的左子结点是2i+1，否则结点i没有左子结点。
		2. 当2i+2<=n-1时，结点i的右子结点是2i+1，否则结点i没有右子结点。
	3. 对于i
		1. i为偶数且0<i<n时，结点i的左兄弟是结点i-1，否则结点i无左兄弟。
		2. i为奇数且i+1<n时，结点i的右兄弟是结点i+1，否则结点i无右兄弟。
## 5.2 周游二叉树
### 5.2.1 抽象数据类型ADT
**声明二叉树BinaryTree类为结点类BinaryTreeNode的友元类**
#### 遍历二叉树
##### 遍历
- 按照一定次序访问结点
- 每个结点被访问一次
##### 二叉树的线性化
实质是把二叉树结点放入一个**线性**序列的过程。
### 5.2.2 深度优先周游二叉树
#### 遍历分类
- 根节点遍历时机的决定性
- 子树遍历结果的连续性
- 遍历过程的递归性
##### 前序周游
##### 中序周游
##### 后序周游
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310111134339.png)
#### 遍历分析
1. 抹去Visit(root)语句，发现访问路径实际上是相同的，只是访问结点的时间不同。
每个结点经过**3次**。
第1次经过访问：先序遍历。
第2次经过访问：中序遍历。
第3次经过访问：后序遍历。
2. 二叉树遍历的时间/空间复杂性：
	- 时间复杂性：O(N)
	- 空间复杂性：O(log(N+1)).
#### 遍历性质
1. 由先（后）序和中序序列，可以唯一确定一棵二叉树。
2. 已知二叉树的先序序列和后序序列，<mark>不能唯一确定<mark>一棵二叉树。
#### 重构树
已知前序和中序遍历序列。（这是一种二叉树的**存储**方式）
#### 递归->非递归
要借助**栈**来实现。
多看多其中思路。
后序：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310130828829.png)
#### 复杂性分析
- 各种遍历中，每个结点都被访问且只被访问一次，时间代价为o(n)。
- 非递归保存入出栈时间：不超过O(n)。
- 栈的深度与**树的高度**有关：最好O(logn)，最坏O(n)。
### 5.2.3 广度优先周游二叉树
- 从根节点开始，自上而下逐层遍历。
- 同层结点按从左到右的顺序对结点逐一访问。
- 实现方式：**队列**（STL）
- 空间复杂性：队列的长度与**树的宽度**相关。
## 5.3 二叉树的存储结构
### 5.3.1 动态链式存储结构
- 二叉链表表示法：本身数据和left和right指针，子女为空时指针为空指针。
- 三叉链表：增加一个指针parent。
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310130850210.png)

### 5.3.2 静态顺序存储结构
**静态数组存储（完全二叉树）**
二叉树是非线性结构，必须将二叉树的结点排成一个线性序列，使得**通过结点在序列中的相对位置确定结点间的逻辑关系**。
对于非完全二叉树的存储，链式存储的优点：
- 不浪费空间
- 插入删除方便
<mark>注意<mark>：完全二叉树的顺序存储，在**存储结构**上是线性的，但在**逻辑结构**上是二叉树型结构。
## 5.4二叉搜索树（BST）
Binary Search Tree（BST），也称二叉排序树。
### 5.4.1 性质
- 或者是空树。
- 对于任何值为k的结点，该结点的左子树中结点值都小于k；
- 该结点右子树的结点值都大于k；
- 左右子树也为二叉搜素树。
- 按照**中序周游**将各结点打印出来，将得到**由小到大**的排列。
### 5.4.2 BST的搜索过程
假设要检索K：
- K与根结点比较。
- 区分检索左子树还是右子树。
- <mark>效率高<mark>：只需检索两个子树之一。**O(logn)**
### 5.4.3 BST的插入
新结点插入后仍是二叉搜索树，值不重复。
### 5.4.4 性能分析
- 插入一个新结点操作的时间复杂度的根到插入位置的路径长度，因此效率相当高。
### 5.4.5 BST的平衡问题
- 希望保持理想状态。
- 插入、删除、查找时间代价为O(logn)。
### 5.4.6 BST的删除
#### 最初
- 如果结点pointer没有左子树，用pointer右子树的根代替被删除的结点pointer。
- 在左子树里按照中序周游找到最后一个结点（最右边的量）yemppointer，把yemppoiter的右指针置为pointer右子树的根，然后用结点pointer左子树的根代替被删除的结点pointer。
**问题**：高度失衡，效率降低。
#### 改进
- 如果结点pointer没有左子树，用pointer右子树的根代替被删除的结点pointer。
- 如果结点pointer有左子树，取出左子树中序周游的最后一个结点p（左子树中最大的数放过去就好），将其从中删除。
- 由于p没有右子树，删除p只需用p的左子树代替p，然后用p结点代替要删除的结点pointer。
## 5.5 堆与优先队列
### 5.5.1 堆的定义
#### 最小值堆
关键码序列{K0,K1,...,Kn-1}，由完全二叉树表示，有如下特性：
- Ki<=K2i+1(i=0,1,...,n/2-1)
- Ki<=K2i+2、
### 5.5.2 堆的性质
1. 堆中数据**局部有序**。
	- 结点与其子女值之间存在大小比较关系。
	- 两种堆（最大、最小）
	- **兄弟**之间没有限定大小关系。
2. 堆不唯一。
3. 堆是一个可用**数组表示**的完全二叉树。
### 5.5.3 堆成员函数
- 左孩子：2\*pos+1;
- 右孩子：2\*pos+2;
- 父结点：（pos-1)/2
### 5.5.4 建堆过程
- 先建立一个完全二叉树，但并不具备最小堆的特性。(**仅叶子结点代表的子树已经是堆**)
- 从完全二叉树的倒数第二层的i(n/2-1)位置开始，**从右至左，从下至上**依次调整。
- 直到树根，整棵完全二叉树就成为一个堆。
<mark>筛选<mark>：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310181058095.png)
<mark>建堆<mark>：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310181058777.png)
#### 建堆效率
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310181115409.png)
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310181119236.png)
#### 移出最小值
- 移出最小值（根节点）。
- 将堆中最后一个位置上的元素移到根节点，利用siftdown调整。
#### 删除元素
将Pos元素和最后一个元素互换位置，currentsize--。之后对pos处的元素向上筛、向下筛，仍为堆。
### 5.5.5 优先队列
## 5.6 Huffman编码树及其应用
- 计算机二进制编码：ASII码等。
- 等长编码：假设所有编码都等长，表示n个不同的字符需要logk n位。字符的使用频率相等。
- 频率不等的字符，可以利用字符的出现频率来编码。
### 5.6.1 Huffman编码树
#### 定义
<mark>定义<mark>：具有最小带权路径长度的二叉树叫做**哈夫曼树（或称最优二叉树）**
<mark>外部结点<mark>
#### 建立
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310181152299.png)

### 5.6.2 Huffman编码
对应的二进制前缀码就称作**Huffman**编码。
#### 性质
- 将代码与字符相联系
	- 不等长编码
	- 代码长度取决于对应字符的相对使用频率或“权重”
- 任何一个字符的编码都不是另一个字符编码的前缀。
### 5.6.3 译码
### 5.6.4 Huffman树构造
### 5.6.5 K叉Huffman树
如果字符个数不是K的整数倍怎么办？
# 6.树
## 6.1 树的概念
### 6.1.1 树的定义
- 树是包括n个结点的有限集合T（n>=1），使得：
	- 一个根结点
	- 除根以外，其他结点被分成m个**不相交的集合**T1,T2,..,TM,而且每个集合都是树。树T1,T2,...,TM称作这个根的**子树**。
- 定义是**递归的**。
#### 逻辑结构
#### 树形结构的表示法
- 树形表示法
- 文氏图表示法
- 凹入表表示法
- 嵌套括号表示法
#### 树的基本术语
结点、结点的度、叶结点、分支结点、子女、双亲、兄弟、祖先、子孙、结点层次、树的深（高）度、树的度、有序树、无序树、森林。
#### 树结构中的概念
- **度为2的有序树并不是二叉树**。度为2并且严格区分左右两个子结点的有序树才是二叉树。
- 有序树：从左到右次序编号。
### 6.1.2 森林与二叉树的等价转换
- **树或森林与二叉树一一对应**。
- 树或森林所对应的二叉树中：
	- 一个结点的左子结点是它在原来树里的第一个结点。
	- 右子结点是它在原来的树里的下一个兄弟。  **左孩子，右兄弟**
#### 森林到二叉树的等价转换
- **加线**：在树中所有相邻的兄弟之间加一连线。
- **抹线**：对树中每个结点，除其最左孩子外，抹去该结点与其余孩子间的连线。
- **整理**：以树的根结点为轴心，将整数顺时针转45°。
#### 二叉树到森林的等价转换
- 加线：若p结点是父结点的左孩子，则将p的右孩子，右孩子的右孩子，...沿分支找到的所有右孩子，都与p的双亲用线连起来。
- 抹线：抹掉原二叉树中双亲与右孩子之间的连线。
- 调整：将结点按层次排列，形成树结构。
### 6.1.3 树的抽象数据类型
### 6.1.4 树（森林）的周游
#### 按深度方向周游
##### 先根次序
- 访问根结点。
- 从左到右，依次先根遍历根结点的每一棵子树。
##### 后根次序
- 从左到右，依次后根遍历根结点的每一棵子树。
- 访问根结点。
#### 广度优先周游树（森林）
- 使用队列实现其算法。
- 首先把被周游的树送入队列。
- 每当从队首取出一棵树，访问其根结点后，马上把它的子树按从左到右的次序送到队列尾端。
- 重复直到队列为空。
## 6.2 树的链式存储：维护父子链
### 1.子结点表示法
- 优点：查孩子个数和结点的值容易。
- 缺点：找兄弟结点困难。
- 树的归并容易：只需将一课树的根添加到另一棵树的孩子结点表中即可。
### 2.动态结点表示法：指针数组法
### 3.静态“左孩子/右兄弟”表示法
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310200938020.png)
优点：
- 空间效率比子结点表示法更高。
- 每个结点仅需**固定大小的存储空间**。
### 4.动态“左孩子/右兄弟”表示法
本质上，使用二叉树来替换树。
- 左子结点在树中是结点的最左子结点。
- 右子结点是结点原来的右侧兄弟结点。
- 每个结点均包含固定数目的指针。
判定寻找<mark>父结点<mark>：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310200948906.png)
![](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310270815363.png)

### 5.父指针表示法及在并查集中的应用
- 每个结点仅保存指向其父结点的指针域即可，成为**父指针表示法**。
- 用数组存储树中所有结点，每个结点附设一个“指针”指示其父结点。
- 优点：
	- 寻找父结点只需要O(1)时间。
	- 求树根结点非常方便。
- 缺点：
	- 寻兄弟结点麻烦， 需要查询整个树结构。
	- 没有标识节点的左右次序，适合**无序树**的情况。
#### 并查集
特殊集合，由不相交子集构成。
基本操作：
- Find:找到其对应的根节点。
- Union：归并两个集合。
- Different：判定是否在同一集合/树中。
##### 重量权衡合并规则
- 将结点较少树的根结点指向结点较多树的根结点。
- 这可以把树的整体深度限制在O(logn)。
- 当处理完n个等价对后，任何结点的深度最多只会增加logn次。
##### 路径压缩算法
## 6.3 树的顺序存储
### 6.3.1 带右链的先根次序表示法
- 任何结点的子树的所有结点都直接跟在该结点之后。
- 每棵子树的所有结点都聚集在一起，中间不会插入别的结点。
- 任何一个分支结点后面跟的都是它的第一个子结点（**如果存在的话**）。
- 结点除包含本身数据外，还附加两个表示结构的信息字段ltag（0有子结点，1无子结点）、info、rlink（右指针，指向下一个兄弟）。ltag可以重塑llink，但是占用存储空间更少。
### 6.3.2 带双标记位的先根次序表示法
- 用rtag代替rlink。
- rtag为1，结点无兄弟；rtag为0，有右兄弟。
- 当结点x的rtag为0时，它的rlink应指向结点序列中排在以结点x为根的子树中最后结点的后面的那个结点y。
- **有兄弟结点和无孩子结点一一对应，满足栈特性。**
结点x的兄弟结点y的确定方法：
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202310270932278.png)
**有兄弟就入栈，无孩子就出栈**。
### 6.3.3 带度数的后根次序表示法
- info是结点的数据，degree是结点的度数。
- 将带度数的后根次序转化成森林时
	- 从左至右进行扫描，度为0的结点是叶子结点（也可看做一棵子树）。
	- 当遇到度数非0（设为k）的结点时，则排在该结点之前且离它最近的k个子树的根就是该结点的k个子结点。
- 利用栈实现：
	- 遇到零度顶点就入栈。
	- 遇到非零k度顶点就从栈中弹出k个节点作为其子结点，然后将该非零顶点入栈。
	- 持续扫描，直至序列扫描完毕。
- 思考：
	- 带度数的先根次序？ 从右到左即可。
	- 带度数的层次次序？
### 6.3.4 带双标记的层次次序表示
- 先看rtag：
	- rtag=0：下一个结点即为其兄弟结点。
	- rtag=1：无兄弟结点。
- 再看ltag：
	- ltag=1：无孩子结点。
	- ltag=0：有孩子结点。<—**重点考虑**
- **有孩子节点与无兄弟节点一一对应，满足队列特性。**
- **有孩子则入队列，无兄弟则出队列**。
## 6.4 K叉树
K叉树的结点有K个**有序子结点**。
# 期中考试整理
## 求最大矩形面积
> 给定 n 个非负整数，代表柱状图上每个柱的高度（每个柱的宽度均为 1），求这个柱状图中最大的矩形面积。

## O(n^3)
枚举所有左右边界可能性，并且在边界内找最低的柱子，枚举边界复杂度O(n^2)，找最低柱子O(n)，总复杂度O(n^3)
## O(n^2)
- 枚举每个柱子作为右边界，往回枚举所有之前的柱子作为左边界，枚举过程中记录最低柱子，则最矮柱子\*左右边界距离为当前矩阵面积。
- 取所有这样的面积最大值，右边界有O(n)种可能，往回找比它矮的柱子也是O(n)，总复杂度为O(n^2)
## O(n)
- 关键：维护一个栈，用于存储直方图柱子中的索引，并保证栈中索引对应的柱子高度递增(**单调栈**)
	- 枚举直方图中的每一个柱子
	- 当栈为空，或者当前柱子的高度大于栈顶柱子的高度时，将当前柱子的索引压入栈。
	- 当当前柱子的高度小于或等于栈顶索引对应柱子的高度时，持续从栈中弹出柱子，直到栈为空或者栈顶柱子的高度小于当前柱子的高度。弹出操作结束后，压入当前柱子的索引。
	- 对于每一个弹出的柱子，计算以该柱子为高度向两边扩展能得到的最大宽度：
		- 若栈非空，最大宽度为当前柱子到弹出柱子的距离(不含当前柱子)
		- 若栈为空，最大宽度为到当前柱子为止的总柱子数减1，根据高度与最大宽度来求当前矩形面积，并更新最大面积。
# 7.图
## 7.1 基本概念
路径、简单路径、路径长度、回路、无环图
有根图、连通图、连通分量(连通分支):无向图的**最大连通子图**
(for有向图)强连通性、强连通分量、网络、自由树
## 7.2 抽象数据类型
- 顶点个数
- 边数
- FirstEdge(int oneVertex);
- NextEdge(Edge preEdge)；
- setEdge(int fromVertex,int toVertex,int weight);
- delEdge(int fromVertex,int toVertex);
- IsEdge(Edge oneEdge);
- FromVertex(Edge oneEdge);
- ToVertex(Edge oneEdge);
- Weight(Edge oneEdge);
## 7.3 存储结构
### 7.3.1 相邻矩阵
A\[G].显然，无向图实际上是一个**对称矩阵**。
相邻矩阵的空间代价为$O(n^2)$,与边数无关。
#### 性质1-对无向图
- 矩阵对称。
- 第i行或第i列中1的个数为顶点i的度数。
- 矩阵中1的个数的一半为图中边的数目。
#### 性质2-对有向图
- 矩阵不一定对称。
- 
### 7.3.2 图的邻接表表示法
- **顶点表**：n个顶点，包括顶点指针和指向边表的指针。
- **边链表**：m条边，包括顶点序号和指向下一表目的指针。
- 无向图需要V+2|E|个存储单元。
- 有向图保存出边表或入边表即可，需要V+|E|个存储单元。
### 7.3.3 十字链表
- 可以看做是“邻接表和逆邻接表”的结合。
- 顶点表：对应图的顶点，存放
	- Data
	- Firstinarc：指针指向第一条以该顶点为终点的边
	- firstoutarc：指针指向第一条以该顶点为起点的边
- 边链表：对应有向图的每一条边。
	- 起点fromvex，终点tovex，边权值info
	- fromnextarc：指针指向下一个以fromvex为起点的边。
	- tonextarc:指针指向下一条以tovex为终点的边。
## 7.4 图的周游（深度、广度、拓扑）
- 从给定顶点V0出发系统地访问G中所有的**顶点**，每个顶点访问一次。
- 需要考虑的情况：
	- 非连通图
	- 存在回路的图：有可能陷入死循环
- 解决办法：
	- 顶点保留一**标志位**，初始时标志位置**未访问**。
	- 在周游过程中，当顶点被访问时，标志位置**已访问**。
### 7.4.1 深度优先搜索（DFS）
递归访问V邻接的未被访问的顶点
#### 复杂性分析
时间复杂度：
- 采用邻接表表示时，有向图总代价为θ(|V|+|E|),无向图为θ(|V|+2|E|)
- 采用相邻矩阵表示时，处理所有的边需要θ(|V|^2）
### 7.4.2 广度优先搜索（BFS）
与DFS时间复杂度相同，二者实际上只是访问顺序不同而已。
### 7.4.3 拓扑排序
#### 问题定义
- 先决条件：以某种**线性顺序**来组织多项任务，以便能够在满足**先决条件**的情况下逐个完成各项任务。
- **有向无环图**能够模拟先决条件。
- 将一个有向无环图中所有顶点在不违反先决条件关系的前提下排成线性序列的过程称为拓扑排序。
#### 性质
1. 拓扑序列不唯一。
2. 环存在时不存在拓扑序列。
#### 基本思想
- 限定有向无环图
- 方法
	- 从图中选择一个<mark>入度为0<mark>的顶点并输出
	- 从图中删除此顶点及所有的出边（**出边关联顶点的入度减1**）
	- 回到第一步继续执行
- 环路存在时
	- 排序结束，仍有顶点没有被输出
	- 但在剩下的图中找不到入度为0的顶点
#### 算法
##### 基于邻接矩阵的实现
- 入度为0：A中全0的列
- 删除某个顶点的出边：对应行清0
##### 基于邻接表的实现
###### BFS方法
队列方式实现：
先初始化标记数组；再让图中**入度为0的**顶点依次入队。
###### DFS方法
- 栈的使用
- 逆序序列
- 环的判断：深度优先拓扑排序不能判断环的存在
#### 复杂性分析
##### 时间复杂度
- 采用相邻矩阵时，每次寻找入度为0的顶点需要θ（V^2）的时间，那么对V个顶点而言，总代价为θ（V^3）。
- 采用相邻表时，总代价为θ(2\*V+E)。
## 7.5 最短路径
**带权图的最短路径问题**
广度优先遍历本质上就是单位权重图的最短路径搜索问题。
### 7.5.1单源最短路径-Dijkstra算法(贪心算法)
- 条件：<mark>边权非负<mark>
- 算法：贪心算法
- 结果由近及远生成以起始点V0为根的有向树。
- 每次从何距离已生成最短路径的节点集“一步之遥”的节点中，选择<mark>距离原定V0最近的边进行延伸<mark>。
#### 具体过程
- 初始化：第一组只包括源点S，第二组包括其他所有顶点。
- 过程：每次从第二组的顶点中选一个其距离值最小的顶点Vm加入第一组中
	- 每往第一组加入顶点Vm，要对第二组各顶点的距离值进行一次修正。
	- 修改后再选距离值最小的顶点加入到第一组中，重复上述过程。
	- 结束条件：直到图的所有顶点都包括在第一组中或者再也没有可加入到第一组的顶点存在。
- 借助：一个长度为N的数组，包括
	- 源点到当前节点的路径长度(length)
	- 当前节点的前驱结点(pre)
#### 时间复杂度
- 如果不采用最小堆的方式，而是通过两两比较来扫描D数组：θ(V^2)。
- 如果采用最小堆的方式：θ((V+E)\*logE)。
#### 延伸之Johnson算法
### 7.5.2 每对顶点间算法的最短路径-Floyd算法(动态规划)
- 借助相邻矩阵，递归地产生矩阵序列adj，adj(k)[i,j]对应**从Vi到Vj中间顶点序号不大于k**的<mark>最短<mark>路径长度。
- 最短路径有两种情况：
	- 中间不经过Vk,那么有adj(k)[i,j]=adj(k-1)[i,j].
	- 中间经过顶点Vk,那么有adj(k)[i,j]=adj(k-1)[i,k]+adj(k-1)[k,j].
- 确定最短路径：
	- 设置一个nxn的矩阵Path,path[i,j]是**由顶点vi到顶点vj的最短路径上排在顶点vj前面的那个顶点**，即当k是使得adj(k)[i,j]达到最小值，那么就置path[i,j]=path[k,j]
	- 如果当前没有最短路径时，就将path[i,j]置为-1
- 时间复杂度：三重for循环，复杂度是O(n^3)，适合稠密图。
### 7.5.3 Bellman-Ford(SPFA)算法
[Bellman-Ford和SPFA伪代码以及分析](https://blog.csdn.net/qq_33375598/article/details/104369596)
#### 思想
1. 用dis数组记录点到有向图的任意一点距离，初始化起点距离为0，其余点均为INF，起点入队。
2. 判断该点是否存在。（未存在就入队，标记）
3. 队首出队，并将该点标记为没有访问过，方便下次入队。
4. 遍历以对首为起点的有向边（t,i）,如果dis[i]>dis[t]+w(t,i),则更新dis[i]。
5. 如果i不在队列中，则入队标记，一直到循环为空。
循环判定：while(!a.Queue.empty())。
#### 判断负环
用Num[i]数组记录每个点进入队列的次数，如果超过n次，说明存在负环。
#### 时间复杂度
O(kE).k为常数，一般不超过2；但是最差情况下，如果存在负环（存在某个点进队列次数超过n），对应时间复杂度为O(VE)。V为顶点数，E为边数
## 7.6 最小支撑（生成）树
- 保证图的连通性
- 边权值总和最小
### 7.6.1 Prim算法
**MST不唯一，但是最小权值是确定的**
#### 证明
#### 时间复杂度
与Dijkstra算法比较：
- 相同：都是贪心的思路
- 不同：
	- Prim算法要寻找的是离**已加入顶点**距离最近的点
	- Dijkstra寻找的是离**源点**距离最近的点
- 其时间复杂度分析与Dijkstra算法相同
### 7.6.2 Kruskal算法
#### 基本思想
- 对于图G，开始时将顶点集分为|V|个等价类，每个等价类包括一个顶点。
- 以权的大小为顺序处理各条边，如果某条边连接两个不同等价类的顶点，则这条边被添加到MST，两个等价类被合并为一个。
- 反复执行此过程，直到只剩下一个等价类。
#### 性能分析
- 使用了路径压缩，differ和UNION函数几乎是常数
- 假设可能几乎对所有边都判断过了，则最坏情况下算法时间代价为O(|E|log|E|),即堆排序的时间
- 适用于**稀疏图**
### 7.6.3 次小生成树
1. 假设我们找了一棵最小生成树T，那么遍历不在T中的所有边(u,v)，加入(u,v)之后，会形成一个环，我们应该删除这个环中从u到v路径的次大边，这样得到的就是次小生成树（证明的话就还是我的作业里面那个证明）。对于这个环，最长边一定是我们加入的(u,v），不然T就不是最小生成树了。于是，就变成了我们遍历不在T中的(u,v），先删除T中从u到v的路径上的最长边，再加入(u,v），这样来得到次小生成树。
2. 那么我们如何得到T中u到v路径上的最长边呢？用倍增法求公共祖先的过程中就可以求得，假设公共祖先为LCA，那么路径为u->LCA->v，我们可以求u到LCA路径中权值最大的边x1,和v到LCA路径中权值最大的边x2.x1和x2中的最大值即为u->v路径中权值最大的边。
3. 那么倍增法的思想是什么样的呢？可以看这个[树上倍增的写法和应用](https://blog.csdn.net/Saramanda/article/details/54963914?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-54963914-blog-82935250.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-54963914-blog-82935250.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=2)。利用dps[]数组和fa`[][]`数组，去求。fa\[i]\[j]表示i的第$2^j$个父亲，那么就有fa\[i]\[j]=fa\[fa\[i]\[j-1]]\[j-1].**i的第2^j个父亲 是i的第2^(j-1)个父亲的第2^(j-1)个父亲**。这样可以把复杂度从n降为logn。
4. 在dfs求fa和dps的过程中，如果想要同时记录i到第2^j个父亲的路劲上最长边的边权，可知其满足maxlen\[i]\[j]=max{maxlen\[i]\[j-1],maxlen\[fa\[i]\[j-1]]\[j-1]}的递推。在dfs中加入这个递推即可，就可以求出任意u,v分别到其公共祖先的路径上的最长边，也就是u->v路径上的最长边。
# 8.内排序
## 8.1 基本概念
- 记录Record：进行排序的基本单位
- 关键码Key：唯一确定记录的**一个或多个**域
- 排序码Sort Key：作为排序运算依据的**一个或多个**域
- 序列Sequence：线性表，由记录组成的集合
- 排序Sorting：将序列中的记录按照排序码特定的顺序排列起来，即排序码域的值具有不减（或不增）的顺序
- 稳定算法与不稳定算法
- 排序算法的衡量标准
	- 时间代价：记录的比较和交换次数
		- 最小时间代价
		- 最大时间代价
		- 平均时间代价
	- 空间代价：所需**附加**空间大小
- 分类
	- 简单排序O(n^2)
		- 插入排序
		- 直接选择排序
		- 冒泡排序
	- Shell排序
	- 分支排序
		- 快速排序Quicksort
		- 归并排序Mergesort
	- 堆排序
	- 分配排序
## 8.2 简单排序
### 8.2.1 插入排序
依次将每个待排序的记录插入到一个有序子文件的合适位置。
**从后往前**比较。
算法优化
#### 基于二分查找的插入排序
最佳情况下查找时间为O(nlogn)，但是最差情况下依然为O(n^2).
### 8.2.2 冒泡排序
#### 基本思想
不停地比较相邻的记录，如果不满足排序要求，就交换相邻记录，直到所有的记录都已经排好序。
#### 算法
```c++
\\向前冒泡
for(int i=1;i<n;i++)
  for(int j=n-1;j>=i;j--)
    if(Array[j]<Array[j-1])
        swap(Array,j,j-1);
```
#### 算法分析
- 算法是稳定的
- 空间代价O(1)
- 时间代价：交换次数最多为θ(n^2)，最少为0，平均为θ(n^2)。
#### 优化
### 8.2.3 直接选择排序
#### 基本思想
每一趟在后面n-i个待排记录中选取最小记录和第i个记录互换。
#### 具体过程
- 首先，在n个记录中选择最小者与r[0]互换；
- 然后，从剩下n-1个记录中选择最小者与r[1]互换；
- 如此下去，直到全部有序为止。
#### 分析
时间效率：O(n^2)
空间效率：O(1)
算法稳定性：**不稳定**
### 8.2.4 时间代价对比
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202311221023688.png)
## 8.3 Shell排序
### 思想
- 又称“**缩小增量排序**”
- 它的提出基于插入排序的2个性质：
	- 在待排序序列较短情形下效率高
	- 在整体有序的情形下时间代价低
### 具体实现方法
- 选定一个**间隔增量序列**(n>d1>d2>...>dt=1)
- 将文件按d1分组（彼此相距d1的记录化为1组），在各组内采用直接插入法进行排序。
- 分别按d2,...dt重复上述分组和排序工作。
- Shell最早提出的增量序列为d1=[n/2]，d(i+1)=[di/2]。
### 分析
- Hibbard增量序列
	- {$2^k-1,2^{k-1}-1,...,7,3,1$}
	- Hibbard增量序列的Shell排序的效率可以达到θ($n^{3/2}$)
- 希尔排序是一种**不稳定**的排序方法
## 8.4 基于分治法的排序
- **分而治之**思想
	- 将原始序列分为若干个子部分，然后分别进行排序。
	- 是解决问题的重要思想方法之一。
- 两种算法
	- 快速排序quick sorting
	- 归并排序merge sorting
### 8.4.1 快速排序
#### 总算法
```c++
void QuickSort(Record A[],int left,int right)
{
	if(left<right)
	{
		int pivot=SelelctPivot(left,right);//选择轴值
		pivot=Partition(A,left,right);//序列分割
		QuickSort(A,left,pivot-1);//对左子序列递归
		QuickSort(A,pivot+1,right);//对右子序列递归
	}
}
```
#### 轴值选择
从待排序列中选择轴值k(参考点)为划分基准。
- 固定位置法
- 中值位置法
- 随机选择法
#### 序列划分
划分为子序列L和R，L中记录都<=k，R中记录都>k.k处于正确排序位置。
- 选择首元素为轴值：pivotValue=Array[left]。
- 左右分别分析、比较、交换
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202311221057695.png)

#### 递归排序
对子序列进行递归划分，直到仅含1或9=0 个元素。
#### 算法分析
- 最佳性能：T(n)=O(nlogn)
- 最差性能：T(n)=O(n^2)
- **平均性能**：T(n)=O(nlogn) 【<mark>分析见PPT<mark>】
### 8.4.2 归并排序
#### 基本思想
- 简单地将原始序列划分为两个子序列
- 分别对每个子序列递归划分，直至不可划分为止
- 最后将排好序的子序列合并为一个有序序列，即**归并过程**
- 快速排序侧重于**分割**，而归并排序侧重于**归并**
- 详细伪代码见PPT
#### 性能分析
- 时间复杂度为O(nlogn)
- 空间复杂度为O(n)
- 是**稳定排序算法**
## 8.5 堆排序
#### 算法分析
- **非稳定性排序**
- 建堆：θ(n)
- 删除一次堆顶重新建堆：θ(logn)
- 一次建堆，n次删除堆顶，总时间代价为θ(nlogn)
- 理论上，堆排序最佳、最差、平均情况下的时间代价均为θ(nlogn)
- 辅助空间代价：θ(1)
## 8.6 分配排序
- 相比前面比较和交换完成的排序，分配排序要通过**分配**和**收集**
- 前提假设：需要事先知道待排序序列中记录的一些具体情况 
	- 如所有记录值都固定在某个区间`[0,m)`.
### 8.6.1 桶排序Bucket Sorting
#### 思想
- 标记为m个桶（`[0,m)`
- 将相同值的记录**分配**到对应桶中
- 将桶号依次**收集**记录，组成有序序列
#### 实现
- **后继起始下标**
- 设置Count数组
	- Count[i]=Count[i-1]+Count[i]：得到<mark>后继起始下标数组<mark>
	- `for(i=n-1;i>=0;i--) Array[--count[TempArray[i]]]=TempArray[i];`
#### 算法分析
##### 时间代价
- 统计计数：θ(m+n)
- 总时间代价：**θ(m+n)**
##### 空间代价
- 需要m个计数器，n个临时空间
- 总的空间代价为**θ(m+n)**
- 适用于<mark>m相对于n很小的情况<mark>
##### 稳定性
**稳定算法**
### 8.6.2 基数排序
- 排序码由多个部分组成
	- 序列R={r0,r1,...,r(n-1)}，每个排序码K由d位子排序码组成 K=(k(d-1),...,k1,k0).
	- R有序就是相对于任意两记录Ri,Rj，满足：(ki,d-1，ki,d-2，...，ki,0)<=(kj,d-1，kj,d-2，...，kj,0)
- Ki的取值范围成为**基数**，记作r
#### 分类
##### 高位优先法
- 分、分、分...、分、收的过程
- 这是一个递归分治问题
##### 低位优先法
- 分、收，分、收，分、收...的过程
#### 实现
**基于LSD方式进行算法实现**
##### 1.基于顺序存储
- 数组R长度：n
- 基数：r
- 排序码位数：d
###### 算法分析
- 空间代价
	- 临时数组n
	- r个计数器
	- θ(n+r)
- 时间代价
	- 桶排序：θ(r+n)
	- d次桶排序
	- 总的时间复杂性：θ(d\*(r+n))
##### 2.基于静态链存储
- 将分配出来的子序列存在r个(静态链组织的)队列中
- 静态链式存储避免了**在分配和收集时都需要移动所有记录**,导致时间代价也高
###### 静态队列定义
```c++
class Node{
	public:
		int key;//结点关键值
		int next;//后继结点下标
};
calss StaticQueue{
	public:
		int head;//头指针
		int tail;//尾指针
};
```
###### 基数排序算法
```c++
for(i=0;i<n-1;i++)
	Array[i].next=i+1;
Array[n-1].next=-1;
for(i=0;i<d;i++)
{
	Distribute(Array,first,i,r,queue);
	Collect(Array,first,r,queue);
}
```
###### 分配过程算法
```c++
while(first!=-1)
{
	int k=Array[first].key;
	//取第i位排序码数字
	for(int a=0;a<i;a++)
		k=k/r;
	k=k%r;
	if(queue[k].head<mark>-1)
		queue[k].head=first;
	else
		Array[queue[k].tail].next=first;
	queue[k].tail=first;//尾部
	first=Array[first].next;//继续分配下一个记录
}
```
###### 收集过程算法
- t\[i]与h\[i+1]进行连接即可
```c++
while(queue[k].head<mark>-1)k++;
first=queue[k].head;
last=queue[k].tail;
while(k<r-1){
	k++;//收集下一个非空队列
	while(k<r-1&&queue[k].head<mark>-1)k++;
	if(queue[k].head!=-1)
	{
		Array[last].next=queue[k].head;
		last=queue[k].tail;
	}
}
Array[last].next=-1;//收集完毕
```
###### 算法分析
- 空间代价
	- n个记录指针空间
	- r个子序列的头尾指针
	- O(n+r)
- 时间代价
	- 不需要移动记录，只需修改next指针
	- O(d\*(n+r))
	- r一般较小，时间代价可以视为O(d\*n)
		- 实际上的时间复杂度为**O(nlogn)**
		- 没有重复编码的情况下，需要n个不同的编码来处理他们
		- 也就是说，$d>= log_r{n}$,即O(nlogn)
### 8.6.3 索引排序
- 记录自身规模较大时，减少记录移动次数能有效降低排序时间
- “**索引排序**”，或称“**地址排序**”
	- 让数组中每一个单元存储指向对应记录的地址，需要移动记录时，只移动地址(或索引)，而不移动记录本身。
- 索引形式，两个问题
	- Index1：对Array而言，SortedArray\[Index1\[i]]=Array\[i]
	- Index2：对SortedArray而言，SortedArray\[i]=Array\[Index2\[i]]
#### I.索引排序Index Sort
- 我们只讨论Index2，过程会形成一个<mark>环<mark>
- 每个环中拷贝操作数目为length+1
- 发现：**Array和SortedArray可以共享同一个数组**
```c++
IndexArray[i]=i;

for(i=1;i<n;i++)
	for(j=i;j>0;j--)
		if(Array[IndexArray[j]]<Array[IndexArray[j-1]])
			swap(IndexArray,j,j-1);
		else
			break;
AdjustRecord(Array,IndexArray,n);
```
#### II.记录调整 AdjustRecord
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202311240947390.png)
## 8.7 各种排序算法的理论和实验时间代价
见PPT
## 8.8 排序问题的界
- Lower Bound
	- 解决排序问题能达到的最佳效率
- Upper Bound
	- 指已知最快算法所达到的最佳渐进效率
- 排序问题的下限应该在sigma(n)到O(nlogn)之间
# 9.外排序
## 9.1 主存储器和外存储器
- 外存储器
	- 优点：永久存储能力、便携性
	- 缺点：访问时间长，比访问内存慢5~6个数量级
**我们应该尽量减少访外存次数**
## 9.2 文件的组织和管理
- 操作系统以文件的方式组织数据
## 9.3 外排序
### 外排序的基本过程
#### 置换选择排序
- 目的：把外存文件初始化为尽可能长的顺串集
#### 归并排序
- 目的：把顺串集逐趟归并排序，形成全局有序的外存文件
### 外排序的时间组成
1. 产生初始顺串的内排序所需时间
2. **初始化顺串和归并过程**所需的读写(I/O)时间
3. 内部归并所需要的时间
**减少外存信息的读写(I/O)次数是提高外部排序效率的关键**
### 9.3.1 置换选择排序
- 目的：将文件生成若干初始顺串(顺串越长越好，个数越少越好)
- 实现：借助在RAM中的堆来完成
#### 算法
- 初始化最小堆：**目的是提高RAM中排序的效率**
	- 从缓冲区读M个记录放到数组RAM中
	- 设置堆尾标志:LAST=M-1
	- 建立一个最小值堆
- 重复以下步骤，直到堆空(**结束条件**)
	- 把具有最小关键码值的记录(根结点)送到输出缓冲区
	- 设R是输入缓冲区中的下一条记录
		- 如果R的关键码不小于刚输出的关键码值，则把R放到根结点
		- 否则，使用数组中LAST位置的记录代替根结点，然后把R放到LAST位置(**等待下一顺串处理**)，设置LAST=LAST-1
	- 重新排列堆，筛出根结点
#### 分析
- 算法结束后，RAM中也填满了不能处理的数据，直接建成堆，留待下一顺串来处理
- 大小是M的堆，最小顺串的长度为M的记录
	- 至少原来堆中的那些记录将成为顺串的一部分
	- **最好情况下，有可能一次就把整个文件生成一个顺串**。什么情况？
	- 平均长度2M
### 9.3.2 归并排序
**二路归并**
#### 归并性质
- m为顺串的个数
- 合并树高log2m+1，进行log2m遍扫描
- 2个输入缓冲区，1个输出缓冲区
#### 归并趟数
- 所需读写外存次数与归并趟数有关系
- 假设有m个初始顺串，每次对k个顺串进行归并，归并趟数为logkm
- 为了减少归并趟数，可以从两个方面入手
	- 减少初始顺串的个数为m
	- 增加同时归并的顺串数量k
#### 最佳归并树
- 关键是降低对外存扫描的次数
- 把所以初始顺串的块数作为树的叶节点，如果是K路归并则建立K叉-Huffman树。
	- 这样可以使对外存的I/O降到最少，提高归并执行效率。
### 9.3.3 多路归并树
- K路归并指每次将K个顺串合并成一个顺串
- K路归并时，每次需要K-1次比较选出最小记录，代价较大
	- 于是有了**选择树**
	- 目的：提高在K个归并串的当前值中找到最小值的效率
#### 赢者树
- 用完全二叉树作为存储结构
	- 叶节点用数组L\[1...n]表示，内部结点用数组B\[1...n-1]表示
	- 数组B中实际存放的是数组L的索引
- 外部结点L\[i]与内部父结点B\[p]关系
	- 最底层最左端内部结点编号为2^s
		- s=log2n-1
	- 最底层的内部结点数为n-2^s
	- **最底层的外部结点个数(LowExt)为最底层内部结点数的2倍**
	- 最底层外部结点之上所以结点数目offset=2^(s+1)-1
	- L\[i]和P\[p]关系可以表示为：
		- i<=LowExt p=(i+offset)/2
		- i>LowExt   p=(i-LowExt+n-1)/2
- 特点
	- 通过比较两个选手的分数来确定一场比赛的赢家
	- 如果L\[i]的分值改变，那么就沿着从L\[i]到根结点路径，和兄弟结点的值进行比较，根据比赛结构修改二叉树的值
#### 败者树
- 赢者树的一种变体
- 在败者树中，用父结点记录其左右子结点进行比赛的败者，而让获胜者去参加更高阶段的比赛
- 新增结点B\[0]，来记录整个比赛的最终胜者
- 败者树是为了**简化重构过程**，树结构未变
	- 只需要和路径上的节点比较即可，而不需要和兄弟节点比较
##### 初始化败者树
##### 生成败者树
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312061043230.png)
##### 重构败者树
#### 多路归并的效率
- 原始方法：找到每一个最小值的时间是θ(k)，产生一个大小为n的顺串的总时间是θ(k.n)
- 败者树方法
	- 初始化包含k个选手的败者树需要θ(k)的时间
	- 读入一个新值并重构败者树的时间为θ(logk)
	- 故产生一大小为n的顺串的总时间为θ(k+n.logk)
# 10.检索
## 基本概念
### 检索
- 在记录集合中找到"关键码值=给定值"的记录
- 或找到关键码值"符合特点约束条件"的记录集
### 平均检索长度ASL
- 主要操作：**关键码的比较**
- ASL
	- 衡量检索算法优劣的时间标准
	- =${∑_{i=1}^n}P_{i}C_{i}$
### 提高检索效率的方法
- **预排序**
	- 排序算法本身比较费时
	- 只是预处理
- **建立索引**
	- 牺牲一定的空间，提高检索效率
- 散列技术
	- 把数据结构组织到一个表中
## 10.1 线性表的检索
### 10.1.1 顺序检索
- 与线性表里所有记录逐个进行关键码和给定值的比较
- 物理存储：可以顺序、或者链接
- "**监视哨**"顺序检索算法
#### 性能分析
- 成功：ASL=(N+1)/2
- 失败：ASL=N+1
- ASL=P\*ASL(成功)+(1-P)\*ASL(不成功)
	- >(n+1)/2
	- <(n+1)
#### 优缺点
- 优点：插入元素可以直接加在表尾θ(1)
- 缺点：检索时间太长θ(n)
### 10.1.2 二分检索
- 前提：**序列有序**
#### 性能分析
- 最大检索长度：\[log2(n+1)]+1
- 成功的平均检索长度为ASL=log2(n+1)-1
#### 优缺点
- 优点：平均与最大检索长度相近，检索速度快
- 缺点：要排序、顺序存储，不易更新(插/删)
### 10.1.3 分块检索
- <mark>顺序检索与二分检索的折衷<mark>
#### 思想
- **按块有序**
	- n个元素线性表被分为b块
		- 块元素可能不满
	- **块内无序**
		- 块内关键码不要求有序
	- **块间有序**
		- 前块中最大关键码<后块中最小关键码
#### 索引表
- 包含：
	- 各块中最大关键码
	- 各块起始位置
	- 块中有效元素个数
- 索引表是一个递增有序表
	- 索引表是分块有序的
#### 性能分析
- 分为两级检索ASL=ASLb+ASLw
	- 索引表检索ASLb
	- 块内检索ASLw
- 若在索引表内用顺序检索，在块内也用顺序检索
	- ASL=(n+s^2)/2s+1
		- s=$n^{1/2}$时，取最小值$n^{1/2}$
- 若用二分法检索确定记录所在的子表
	- ASL=log2(1+n/s)+s/2
#### 优缺点
- 优点
	- 插入、删除容易
	- 无大量移动记录
- 缺点
	- 增加一个辅助索引表
	- 初始化线性表分块排序
	- 元素大量插入/删除，或分布不均匀时性能下降
## 10.2 散列表的检索
### 10.2.1 散列问题
- 受**数组寻址**启发，根据关键码值直接找到记录存储地址
- 于是发明了散列方法(Hash,"哈希"，"杂凑")：建立起关键码值与存储地址之间的直接映射关系
- **负载因子**a=n/M
	- n:散列表中已有结点数
	- M：散列表中空间大小
- **冲突**
	- <mark>将不同的关键码映射到相同的散列地址<mark>
	- 不产生冲突的散列函数极少存在
- **同义词**
	- 发生冲突的两个关键码
### 10.2.2 散列函数的构造
- 使节点"均匀分布"
- 散列函数：把关键码映射到存储位置的函数，通常用h来表示Address=Hash(key)
- 常用选取方法
#### 1.除余法
- h(x)=x mod M
- 一般M取质数
- 潜在缺点：
	- 连续的关键码映射成连续的散列值
	- 虽然能保证连续的关键码不发生冲突，但是意味着要占据连续的数组单元，可能导致散列性能降低
#### 2.乘余取整法
#### 3.平方取值法
#### 4.数字分析法
- 设有n个d位数，每一位可能有r种不同的符号
- 可根据散列表大小，选取其中各种符号<mark>均匀分布<mark>的若干位作为散列地址
- 计算各位数字中符号分布的均匀度$λ_k=∑_{i=k}^{r}(a_i^k-n/r)^2$
	- $a_i^k$表示第i个符号在第k位上出现的次数
	- $λ_k$值越小，第k位符号分布越均匀
#### 5.基数转换法
- 把关键码看成另一进制上的数，再把它转换成原来进制上的数，取其中若干位作为散列地址
- 一般取大于原来基数的数作为转换的基数，且两个基数要互素
#### 6.折叠法
- 将关键码分割成位数相同的几部分
- 然后取这几部分的叠加和(舍去进位)作为散列地址
- 两种叠加方法：
	- **移位叠加**
	- **分界叠加**
#### 分析与应用
- 统计表明，**平方取中法**最接近于"随机化"
### 10.2.3 冲突的解决方法
#### 开散列方法(拉链法)
- 所有同义词链接在同一链表
- **a可大于1，但一般取a<=1**
##### 拉链方法(适用于内存)
- 散列表的每个槽定义为**链表表头**，槽内所有记录都放到这个槽的链表中
- 同义表的组织
	- 根据输入顺序
	- 根据访问频率的顺序
	- 根据值的顺序
		- 适合检索不成功的情况：一旦遇到一个比待检索关键码大的值，就停止检索
		- 如果记录没排序或者根据访问频率排序，那么一次不成功的检索就需要访问同义词表中的所有记录
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312080841938.png)
- 优点：
	- 处理冲突简单，**不同基地址冲突彼此独立**，平均查找长度短
	- 链表结点动态申请，适用于表长不确定情况
	- 拉链法可取a>=1，且结点较大时，拉链法中增加的指针域可忽略不计，故节省空间
	- 用拉链法构造的散列表，删除结点易于实现
		- 只要简单地删去链表上相应的结点即可
- 缺点：
	- 如果整个散列元素存储于内存，拉链法容易实现
	- 如果散列元素存储在磁盘，拉链法则不太适用
		- 同义词表中的元素可能存储在不同的磁盘页中
		- 会导致在检索一个特点关键码值时引起多次磁盘访问，从而增加了检索时间
	- <mark>引入桶式散列<mark>
##### 桶式散列(适用于外存)
- 适用于存储于磁盘的散列表
- 基本思想
	- 散列文件记录分为若干桶，每个桶包含<mark>若干页块<mark>
	- 桶内各页块用指针链接，每个页块包含若干记录
	- 散列函数h(K)表示具有关键码K的记录所在桶号
- 检索访问
	- 计算H(i)的值，然后调**桶目录表**中包含第i个桶目录的页块进入内存，查到第i个存储桶的第一个页块的地址，然后根据该地址调入相应页块
- 磁盘访问性能
#### 闭散列方法(开地址法)
- 把发生冲突的关键码存储在散列表中另一个空地址内
- d0=h(K)成为K的基址
- 当**冲突**发生时，使用某种方法为关键码K生成一个候选的散列地址序列，称为**探查序列**
- di=d0+p(K,i)是后继散列地址，P(K,i)是**探查函数**
- 基本思想
	- 插入K时，若基地址结点已被占用，则按探查函数生成的探查序列依次查找，将找到的**第一个空闲位置$d_i$作为K的存储位置
	- 若所有后继散列地址都不空闲，说明该闭散列表已满，报告溢出
##### 探查方法(探查函数)
###### 1.线性探查法
- 基本思想：如果记录的基位置存储位置被占用，那么就在表中下移，直到找到一个空存储位置
- **p(K,i)=i**
- 优点：表中所有的存储位置都可作为插入记录的候选
- 缺点：**聚集/堆积**
	- 基地址不同的记录，争夺同一后继地址序列
	- 小聚集汇成大聚集，导致很长的探查序列
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312080922349.png)
- <mark>改进<mark>：每次跳过常数c个而不是一个槽
	- 探查序列中第i个槽<mark>(h(K)+ic)modM<mark>
	- **基位置相邻**的记录就不会进入同一个探查徐磊了
	- p(K,i)=i\*c
###### 2.二次探查法

###### 3.伪随机数序列探查法
- 探查函数p(K,i)=perm\[i-1]
	- perm是一个长度为M-1的数组
	- 值从"1~M-1"的随机序列
- 聚集
	- **基本聚集**：
		- <mark>基地址不同的关键码<mark>，其探查序列的某些段重叠在一起
		- 伪随机探查和二次探查可以<mark>消除基本聚集<mark>
	- **二次聚集**：
		- 如果**两个关键码散列到同一个基地址**，还是得到同样的探查序列，产生聚集
		- 原因：探查序列只是基地址的函数，与关键码值无关
		- 解决：双散列探查法
###### 4.双散列探查法
- 避免二级聚集
	- 探查序列是原来关键码值的函数
	- 而不仅仅是基地址的函数
- 双散列探查法
	- 利用第二个散列函数作为尝试
	- 每个跳过常数项，做线性探查
- 基本思想
	- 两个散列函数h1,h2
	- 若在h1(key)=d发生冲突，则计算h2(key)
	- 序列公式$d_i=(d+i*h_2(key))\% M$
	- 探查函数:p(K,i)=i\*h2(key)
- h2(key)必须与M互素
	- 使发生冲突的同义词地址均匀地分布在整个表中
	- 否则可能造成同义词地址的循环计算
- 优点：不易产生聚集
- 缺点：计算量增大
### 10.2.4 闭散列的算法实现
- **字典Dictionary**
	- 一种特殊集合，其元素是(关键码，属性值)二元组
		- **同一字典内关键码互不相同**
	- 主要操作
		- Insert(key,value)
		- Lookup(key)
	- 用散列表方法高效实现
- ADT
	- Elem EMPTY;//**空槽**
#### HashInsert函数
#### HashSearch函数
#### HashDelete函数
- 注意
	- 删除记录不能影响后续检索
	- 释放的位置能够为将来所用
##### 墓碑
- 设置一个特殊的标记位，来记录散列表中的单元状态
	- **占用、为空、已删除**
	- <mark>遇到空标记检索停止；遇到删除标记检索继续<mark>
	- 被删除标记值称为**墓碑Tombstone**
		- 新记录不能直接存储在墓碑中，**避免插入两个相同的关键码**
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312131029689.png)

### 10.2.5 散列方法的效率分析
- 衡量标准：插入、删除和检索操作的**ASL**
- 散列表的插入和删除操作都是**基于检索进行**的
	- 删除：必须先找到该记录
	- 插入：必须找到探查序列的尾部，即对这条记录进行一次不成功的检索
		- 不考虑墓碑的情况，是尾部的空槽
		- 考虑墓碑的情况，也要找到尾部，才能确定是否有重复记录
- 散列效率与负载因子<mark>α=N/M<mark>有关
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312131036421.png)
- 结论1
	- 散列方法
		- 代价接近于访问一个记录的时间，比logn效率高
		- 不依赖于n，只依赖于负载因子α=N/M
		- 随着α增加，预期代价也增加
		- α<=0.5时，大部分操作的分析预期代价都小于2
	- 经验表明，负载因子的临界值是0.5
- 结论2
	- **散列表的插入和删除操作如果很频繁，将降低散列表的检索效率**
		- 大量的插入操作，使得负载因子增加
			- 从而增加了同义词子表的长度
			- 也就是增加了平均检索长度
		- 大量的删除操作，也将增加墓碑的数量
- 结论3
	- 实际应用中，对于插入和删除操作比较频繁的散列表，可以定期对表进行重新散列
# 11.索引
- 主码(每条记录的唯一标识)与辅码(数据库中可重复出现的码)
- 把关键码与它对应的记录位置关联起来的过程
- <mark>(key,pointer) (关键码，指针)<mark>
- 通过**索引文件**高效访问主文件中的记录
	- 稠密索引：对每个记录建立一个索引项
	- 稀疏索引：对一组记录建立一个索引项
		- <mark>要求主文件必须按照关键码次序存放<mark>
## 11.1 线性索引
- **按照索引码值的顺序进行排序的文件**
- 如果线性索引太大，可以使用<mark>二级索引<mark>
	- 关键码和相应磁盘块中第一条记录的关键码值相同
	- 指针指向相应磁盘块的起始位置
## 11.2 静态索引
- 索引结构在文件创建时生成
- 一旦生成就固定下来，在系统插入或删除的过程中，索引结构不发生改变
- 只有文件再组织时才允许改变索引结构
- 启发：**信息技术的轮回流转**
## 11.3 倒排索引
- 按<mark>属性值<mark>建立索引，索引表中的每一项包括
	- 属性值和具有该属性值的<mark>各关键码或记录地址<mark>
- 由属性值来确定记录的位置，称之为**倒排索引**
- 带有倒排索引的文件称为**倒排文件**
### 11.3.1 基于属性的倒排
- 按属性值建立起来的索引表(attr,ptrList)
	- **属性值**
	- **记录指针**:关键码或者该记录的主文件地址
- 优缺点
	- 优点：支持基于属性的高效检索
	- 缺点：
		- 花费了保存倒排表的存储代价
		- 降低了更新运算的效率
### 11.3.2 对正文文件的倒排
- **正文索引Text Indexing**
	- 支持对文本内容快速检索
#### 关键词索引word index
- 基本思想：从正文中抽取**关键词**，组成索引
- 支持多种文本类型
	- 中文等东方文字要经过"**切词**"处理
#### 全文索引full-text index
- 基本思想：正文看做一个长的字符串
- 可以对**每个字符串**都建立索引
#### 建立正文倒排文件
1. 对文档集中所有文件进行**分割处理**，把正文分成多条记录文档
	- 切分正文记录取决于程序的需要
2. 给每条记录赋一组**关键词**
3. 建立正文倒排表、倒排文件
	1. 得到各个关键词的集合
	2. 对于每一个关键词得到其倒排表
	3. 把所有的倒排表存入文件
		- 记录每个关键词在文件中开始的位置
#### 对关键词的检索
1. 在倒排文件中检索关键词
2. 如果找到了关键词，那么获取文件中的对应的倒排表，并获取倒排表中的记录
3. 使用另一个索引结构(字典)进一步对关键词表进行有效索引
#### 优劣
- 高效检索，用于文本数据库系统
- 支持的检索类型有限
	- 检索词有限(只能使用索引文件中的关键词)
	- 需要的空间代价往往很高
## 11.4 动态索引
- 文件创建时生成
- 结构随着插入、删除等操作而改变
- 目的：保持最佳的检索性能
### 11.4.1 B树
- **m阶B树**是一棵m路查找树：或者为空，或者
	- 有k棵子树的结点有k-1个关键码
	- **上界**：树中每个结点至多有m个子结点
	- **下界**：根结点至少有2棵子树，其他非叶结点至少有\[m/2+1]棵子树
	- 叶结点都位于同一层，有\[m/2+1]到m-1个关键码
#### 性质
- **树高平衡、叶结点同层、关键码不重复**
- 父结点关键码是子结点的分界
- 具有K个子结点的结点包含K-1个关键码
- 访问**局部性**原理
	- 值相近的记录放在相近的磁盘页中
- 节点关键码至少一定比例是满的
	- 改进空间利用率
	- 减少检索
	- 更新操作的I/O数
#### 查找
- 两步交替过程
	- 读取根结点，在所包含的关键码$K_1,...,K_j$中查找给定的关键码：找到则检索成功
	- 否则，确定要查的关键码值是在某个Ki和Ki+1之间，于是去pi所指向的结点继续查找
- 如果pi指向<mark>外部空结点<mark>，表示检索失败
#### 检索长度
- 设B的高度为h(独根树高度为1)
- 在自顶向下检索到叶结点的过程中可能需要进行h次读盘
- 最多需要h+1(**访问主文件数据+1**)次访外
#### 插入过程
> **结构要调整，性质要保持(等高和阶)**

- 找到**最底层**插入
- 若溢出，则结点分裂
	- 指的是关键码插入后关键码数超过上界m-1，则要分裂
	- 中间关键码连同新指针插入父结点
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312131345016.png)

- 若父结点也溢出，则继续分裂
	- **分裂过程可能传达到根节点(则树升高一层)**
#### 访存次数
- 默认约定：<mark>内存足够大，检索时读入的结点，在向上分裂时不必再从磁盘读入<mark>
- 读盘次数与查找相同
	- 写盘次数**最少一次**
	- 如果结点分裂，则将所有更新结点写到外存
- 如考虑对主数据文件访问，则再加一次
- 假如h层，插入操作可能导致最多的I/O次数
	- 分裂一个非根节点要向磁盘写出2个结点，分裂根结点(最后一次)要写出3个结点
	- h+2\*(h-1)+3=3\*h+1
#### 删除
- 删除的关键码不在叶节点层
	- 先把此关键码和它在B树里的**后继位置**对换，然后再删除该关键码
- 删除的关键码在叶节点层
	- 删除后关键码个数**不小于**\[m/2]-1(上取整)
		- 直接删除
	- 删除后关键码个数小于\[m/2]-1(上取整)
		- 如果相邻兄弟结点关键码个数大于\[m/2]-1
			- **借若干关键码**<mark>父结点中的分界关键码要做调整<mark>
		- 否则
			- **合并**
- 假设按如下的方法修改从B树中删除元素的方式：如果一个结点既有最相邻的左兄弟也有最相邻的右兄弟，那么在合并前对两个兄弟都要作检查。从一棵高度为k的B树中删除元素时需要的最大磁盘访问次数？
	- 注：一般而言, B树的层次都很少，查找B树路径中的结点能放在内存中，不必重复访问磁盘读取。
	- 答案为：**4\*K-2**
### 11.4.2 $B^+$树
- B树的一种变形
- 在叶节点上存储信息的树
	- 所有关键码都在叶节点
	- 各层结点中的关键码均是下一次相应结点中最大关键码(或最小关键码)的**复写**
- m阶$B^+$树
	- 每个结点至少\[m/2]个子结点(上取整)
		- 至多m个子结点
	- 根结点至少两个子节点
		- 根为空，或者独根情况除外
	- 有K个子结点的结点必有K个关键码
		- 一个关键码对应一个结点
#### 与B树的差异
- B+n棵子树的结点有n个关键码，B含n-1个关键码
- B+树叶子结点包含完整索引信息，而B树所有结点共同构成全部索引信息
- B+所以非叶结点可以看成是高层索引，结点中仅含有其子树中最大(或最小)关键码
#### 查找
- 查找到叶节点层
	- 在上层已找到待查的关键码，并不停止
	- 继续沿指针向下查到叶节点层的这个关键码
- B+树叶一般连接起来，形成一个双链表
	- 适合顺序检索
	- 实际应用更广
#### 插入
- **插入-分裂**
	- 过程和B树类似：分裂为左\[1,\[m/2]],右\[\[m/2]+1,m+1].(\[]表示取上整)
	- 保证上一层结点中有这两个节点的最大/最小关键码
#### 删除
- 关键码在叶节点层删除后，其在上层的复本<mark>可以保留<mark>，作为一个"分界关键码''存在
	- 也可以替换为新的最大/最小关键码
#### 性能分析
- 包含N个关键码的B树，**有N+1个外部空指针**
- 各层的结点数目
	- 第0层至少1个结点，第1层至少2个结点
	- 第k层至少![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312150903339.png)个结点
- 检索效率(内容见PPT)
	- 存取次数
- 结点分裂次数
## 11.5 红黑树Red-Black Tree
- 红黑树也是BST树的一个变种
- 找寻平衡二叉树
### 11.5.1 定义
- 对**BST树**进行以下约束
	- **颜色两种**：红色/黑色
	- **首尾皆黑**：根和树叶
	- **红红不连**：父子结点不允许红红连续
	- **黑色同阶**：任意结点到其叶节点路径包含相同数目黑结点
- 红黑树的阶
	- 结点X的阶，也称黑色高度
	- 表示从该结点到外部结点的黑色结点数量
	- <mark>不包括X结点本身，包括叶节点<mark>
### 11.5.2 性质
1. 红黑树是满二叉树
	1. 空树叶也看做结点
2. K阶红黑树路径长度
	1. 从根到叶的简单路径长度，即介于\[K,2K]
	2. 或者说树高介于\[k+1,2k+1]
3. k阶红黑树内部结点数
	1. 最少时是一颗完全满二叉树
	2. 内部节点数最少是$2^k-1$
4. n个内部结点红黑树最大高度：$2*log_2(n+1)+1$
### 11.5.3 结点插入算法
- 先调用BST的插入算法，将待插记录定位
	- 约定：新插入记录标记为**红色**
	- 若父结点是黑色，则插入完成
	- 否则，**双红调整**：
		- <mark>红黑旋转<mark>
			- 新增结点X的叔叔结点是黑色，或者NIL
			- 那么进行旋转调整
			- 调整后根结点为黑色，左右兄弟为红色
			- 原则是保持中序性质
		- <mark>红红换色<mark>
			- 新增结点X的叔叔结点也是红色
			- 那么父祖换色，叔父变黑
			- **对祖先继续红红检查**
			- 如果B是根，则父(父&叔叔)换色，祖不变
	- 父&叔颜色
		- 红黑旋转：阶数平衡，停止
		- 红红变色：双红递归，继续
### 11.5.4 结点删除算法
- 先调用BST树的删除算法，**换值不换色**，再删除(<mark>预处理<mark>)
- 换后：
	- 待删节点有1个外部叶节点
		- 则其非空子结点肯定为红色(若黑色则不满足阶相等)， 待删结点肯定为黑色
	- 待删结点有2个外部叶结点
		- 如果待删结点是红色，直接删除
		- 否则，需要标记双黑节点，根据其兄弟结点进行重构调整
			- 情况1：**双黑节点兄弟是红色，那么执行旋转操作**
				- 父结点一定为黑色
				- 旋转：
					- 原兄弟节点旋转为根，然后变黑
					- 原父节点变红
				- X仍为双黑节点，转为情况2&情况3
			- 情况2：**兄弟是黑色，且有两个黑子结点**
				- **父兄换色**
				- 若父亲原来为红色，则调整结束
				- 否则，继续作“双黑”调整
			- 情况3：**兄弟结点C是黑色，且子结点有红色**
				- a.旋转重构：侄子红节点<mark>八字外撇<mark>
					- 将兄弟结点提上去，继承原父亲的颜色
					- 根不变色，双黑结点X的父兄全为黑
				- b.旋转重构：侄子红节点<mark>同边顺<mark>
					- 将侄子以之字形旋转为父结点，继承原来夫妻的颜色
					- 变换后根不变色，X的父兄全为黑
# 12.高级数据结构
## 12.1 多维数组
### 数组的存储
- 行优先顺序：先排最右下标，从右到左，最后排最左下标
- 列优先顺序：先拍最左下标，从左到右，最后排最右下标
- 起始地址\<mark>=第一个元素起始地址+该元素前面的元素个数\*单位长度<mark>
### 特殊矩阵
- 非零元素呈某种规律分布或者矩阵中有大量的零元素，可以进行**压缩存储**
	- 对称矩阵：只需保存上三角或下三角元素
	- 三角矩阵：只存上/下三角元素+另外三角的一个常数 即$n*(n+1)/2+1$
	- 稀疏矩阵：只有少量非零元素，我们只存非零元素
		- 三元组表($i,j,a_{ij}$)存储非零元素
		- 十字链表：行指针与列指针记录实现链表
## 12.2 广义表
### 基本概念
- **Generalized Lists广义表**：如果一个线性表中还包括一个或者多个子表
- L=($x_0,...,x_i,...x_{n-1}$)
	- L是名称，n为长度
	- xi是L 的成员
		- 可以是原子（单个元素）
		- 可以是子表（一个广义表）
	- 广义表深度：表中元素都化解为原子后的括号层数
	- 表头head=$x_0$,表尾tail=($x_1,...,x_{n-1}$)
		- 表头是一个元素，表尾是除了表头的表
### 广义表的类型
- 空表
- 线性表
- 纯表pure list
	- 从根结点到任何叶节点只有一条路径
	- 任何元素只能在广义表中出现一次
- 可重入表(再入表)
	- 其元素可能在表中多次出现
	- 对应一个DAG(无向图)
- 循环表
	- 包含回路，循环深度为无穷大
- 递归表
### 广义表的存储
## 12.3 Trie结构
空间换时间
### Trie树(前缀树)
### PATRICIA树(进阶)
## 12.4 改进的二叉搜索树
### 12.4.1最佳BST树
- 基于用户访问习惯
- 一个拥有n个关键码的集合，有n!中不同的排列法，期中只有$C_{2n}^n-C_{2n}^{n-1}={C_{2n}^n}/{(n+1)}$种前序排列可以构成二叉搜索树
#### 扩充二叉搜索树
- 每个扩充得到的外部结点代表其值处于原来二叉搜索树的两个相邻结点关键码值之间的可能关键码的集合
#### 效率度量
- 成功检索
	- 比较次数就是关键码所在层数+1(根为第0层)
- 不成功检索
	- 比较次数就等于被检索关键码所属的那个外部结点的层数
- 平均比较次数
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312220922475.png)
- 最佳BST树
	- 平均比较次数ASL最小的二叉搜索树
	- 如何构造？
#### 构造
##### 1.结点检索概率均等
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312220933043.png)
##### 2.结点不等概率访问
##### 最佳BST树构造方法
- 最佳BST树：**其任何子树都是最佳BST树**
	- 可以从底层逐步构造最佳BST树
	- 较大的最佳BST树由较小的最佳BST树构造而成
	- **动态规划**的基本思想
![image.png](https://zhangzinuo.oss-cn-beijing.aliyuncs.com/img/202312220949902.png)

### 12.4.2 平衡BST树(AVL树)
- 基于树高平衡约束
- 性质
	- 要么为空树
	- 要么：其左右子树$T_L,,T_R$也是AVL树，并且$|h_R-h_L|<=1$
	- 如果T是一棵具有n个结点的AVL树，其高为O(log n).
	- 平衡因子bf(x)=x的右子树高度-x的左子树高度
#### AVL树结点的插入与重构
- 插入结点后失衡，要执行平衡操作。有4种情况
	- 单旋转
		- LL：左子树的左子树导致失衡，A的平衡因子为-2
		- RR：右子树的右子树导致失衡，A的平衡因子为2
	- 双旋转
		- LR：左子树的右子树导致失衡，A的平衡因子为-2
		- RL：右子树的左子树导致失衡，A的平衡因子为2
- 从新加入的结点u向跟方向往上搜索，直到找到距离u最近的不平衡祖先结点A
	- 令A结点指向结点u的路径上的第一个子结点为B，第二个子结点为C，重构操作发生在**A->B->C**结点上
##### 单旋转
- 调整过程仅限A,B两个结点
- 单左/右旋转，保持中序周游序列不变
##### 双旋转
- 调整涉及ABC三个结点
#### AVL树的删除

### 12.4.3 伸展树Splay Tree
- 基于用户动态访问特征
	- 数据访问的"二八规则"
- 一种**自组织**数据结构
	- 数据随**检索而调整**位置
- **展开**
	- 访问一次结点X，完成一次展开过程
		- 插入x时，把结点x移到BST的根结点
		- 删除x时，把结点x的父结点移到根结点
	- 结点x的展开包括一组旋转
		- 调整结点x、父结点、祖父结点，把x旋转到更高层
		- 旋转分为
			- 单旋转
			- 双旋转
#### 单旋转
#### 双旋转
##### 一字形选择(同构调整)
##### 之字形旋转(异构调整)
#### 伸展树的应用与扩展
- 找某个区间的序列
- <mark>半伸展树<mark>
#### 伸展树的效率
- 伸展树不能保证每单个操作是有效率的
	- 某次访问操作的代价为O(n)
- 能够保证m次操作总共需要O(mlogn)时间
	- 即每次访问操作的平均代价为O(logn)
### 12.4.4 几种平衡机制比较
